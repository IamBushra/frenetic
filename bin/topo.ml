open! Core
open Probnetkat
open Probnetkat.Syntax
open Probnetkat.Symbolic
open Frenetic.Network

module Int2 = struct
  module T = struct
    type t = int*int [@@deriving sexp, hash, compare]
  end
  include T
  module Table = Hashtbl.Make(T)
end

module Parameters = struct

  let base_name = Sys.argv.(1)

  (* switch field *)
  let sw = "sw"

  (* port field *)
  let pt = "pt"

  (* counter field *)
  let counter = "failures"

  (* up bit associated with link *)
  let up sw pt = sprintf "up_%d" pt

  (* link failure probabilities *)
  let failure_prob _sw _pt = Prob.(1//10)

  (* Limit on maximum failures "encountered" by a packet. A packet encounters
     a failure if it occurs on a link that is incident to the current location
     of the packet, indepedently of whether the packet was planning to use that
     link or not. *)
  let max_failures = Some 1

  (* topology *)
  let topo = Topology.parse (base_name ^ ".dot")

  (* Destination host. Files generated by Praveen assume this is 1. *)
  let destination = 1


(*===========================================================================*)
(* AUXILLIARY                                                          *)
(*===========================================================================*)

  (* switch id to switch node map *)
  let switch_tbl : Net.Topology.vertex Int.Table.t =
    let open Net.Topology in
    let tbl = Int.Table.create () in
    iter_vertexes (fun v ->
      if Topology.is_switch topo v then
        let id = Topology.sw_val topo v in
        Hashtbl.add_exn tbl ~key:id ~data:v
    )
      topo;
    tbl

  (* (src_sw,dst_sw) |-> edge *)
  let edge_tbl : Net.Topology.edge Int2.Table.t =
    let tbl = Int2.Table.create () in
    Net.Topology.iter_edges (fun edge ->
      let (src,_) = Net.Topology.edge_src edge in
      let (dst,_) = Net.Topology.edge_dst edge in
      if Topology.(is_switch topo src && is_switch topo dst) then
        let key = Topology.(sw_val topo src, sw_val topo dst) in
        Hashtbl.add_exn tbl ~key ~data:edge
    )
      topo;
    tbl

  (* (sw,pt) |-> out edge *)
  let hop_tbl : Net.Topology.edge Int2.Table.t =
    let tbl = Int2.Table.create () in
    Net.Topology.iter_edges (fun edge ->
      let (src_sw, src_pt) = Net.Topology.edge_src edge in
      if Topology.is_switch topo src_sw then
        let key = Topology.(sw_val topo src_sw, pt_val src_pt) in
        Hashtbl.add_exn tbl ~key ~data:edge
      )
      topo;
    tbl

  let parse_sw sw =
    assert (String.get sw 0 = 's');
    String.slice sw 1 (String.length sw)
    |> Int.of_string

  (* switch to port mapping *)
  let parse_trees file : (int list) Int.Table.t =
    let tbl = Int.Table.create () in
    In_channel.(with_file file ~f:(iter_lines ~f:(fun l ->
      let l = String.strip l in
      if not (String.get l 0 = '#') then
      match String.split ~on:' ' l with
      | [src; "--"; dst] ->
        let src = parse_sw src in
        let dst = parse_sw dst in
        let edge = Hashtbl.find_exn edge_tbl (src,dst) in
        let (_, out_port) = Net.Topology.edge_src edge in
        (* find destination port *)
        Hashtbl.add_multi tbl ~key:src ~data:(Topology.pt_val out_port)
      | _ ->
        failwith "unexpected format"
    )));
    Hashtbl.iteri tbl ~f:(fun ~key:sw ~data:pts ->
      printf "sw %d: %s\n" sw (List.to_string pts ~f:Int.to_string)
    );
    tbl

  (* switch to port mapping *)
  let parse_nexthops file : (int list) Int.Table.t =
    let tbl = Int.Table.create () in
    In_channel.(with_file file ~f:(iter_lines ~f:(fun l ->
      let l = String.strip l in
      if not (String.get l 0 = '#') then
      match String.split ~on:' ' l with
      | src::":"::dsts ->
        let src = parse_sw src in
        List.map dsts ~f:(fun dst ->
          let dst = parse_sw dst in
          let edge = Hashtbl.find_exn edge_tbl (src,dst) in
          let (_, out_port) = Net.Topology.edge_src edge in
          Topology.pt_val out_port
        )
        |> fun data -> Hashtbl.add_exn tbl ~key:src ~data
      | _ ->
        failwith "unexpected format"
    )));
    tbl

  (* am I at a good port? *)
  let at_good_pt sw pts = PNK.(
    List.map pts ~f:(fun pt_val -> ???(pt,pt_val) & ???(up sw pt_val, 1))
    |> mk_big_disj
  )

  (* given a current switch and the inport, what tree are we on? *)
  let mk_current_tree_tbl (port_tbl : (int list) Int.Table.t) : int Int2.Table.t =
    let tbl = Int2.Table.create () in
    (* the port map maps a switch to the out_ports in order of the tree preference *)
    Hashtbl.iteri port_tbl ~f:(fun ~key:src_sw ~data:src_pts ->
      List.iteri src_pts ~f:(fun i src_pt ->
        (* if we are on tree i, we go from src_sw to src_pt across the following edge: *)
        let edge = Hashtbl.find_exn hop_tbl (src_sw, src_pt) in
        (* thus, we would end up at the following switch: *)
        let (dst_sw, dst_pt) = Net.Topology.edge_dst edge in
        (* thus, we can infer from entering switch `dst_sw` at port `dst_pt` that
           we must be on tree i
        *)
        let key = Topology.(sw_val topo dst_sw, Topology.pt_val dst_pt) in
        Hashtbl.add_exn tbl ~key ~data:i
      )
    );
    (* for ingress ports, simply start at tree 0 *)
    List.iter (Topology.ingress_locs topo ~dst:destination) ~f:(fun (sw, pt_val) ->
      let key = (Topology.sw_val topo sw, pt_val) in
      Hashtbl.add_exn tbl ~key ~data:0
    );
    tbl



(*===========================================================================*)
(* ROUTING SCHEMES                                                           *)
(*===========================================================================*)

  (* different routing schemes *)
  module Schemes = struct

    let random_walk sw =
      Topology.vertex_to_ports topo sw ~dst_filter:(Topology.is_switch topo)
      |> List.map ~f:(fun out_pt_id -> PNK.( !!(pt, Topology.pt_val out_pt_id) ))
      |> PNK.uniform

    let resilient_random_walk sw =
      let pts = Topology.vertex_to_ports topo sw
        |> List.map ~f:Topology.pt_val
      in
      let choose_port = random_walk sw in
      PNK.( do_whl (neg (at_good_pt sw pts)) choose_port )

    let shortest_path : Net.Topology.vertex -> string policy =
      let port_tbl = parse_trees (base_name ^ "-spf.trees") in
      fun sw ->
        let sw_val = Topology.sw_val topo sw in
        match Hashtbl.find port_tbl sw_val with
        | Some (pt_val::_) -> PNK.( !!(pt, pt_val) )
        | _ ->
          eprintf "switch %d cannot reach destination\n" sw_val;
          failwith "network disconnected!"

    let ecmp : Net.Topology.vertex -> string policy =
      let port_tbl = parse_nexthops (base_name ^ "-allsp.nexthops") in
      fun sw ->
        let sw_val = Topology.sw_val topo sw in
        match Hashtbl.find port_tbl sw_val with
        | Some pts -> PNK.(
            List.map pts ~f:(fun pt_val -> !!(pt, pt_val))
            |> uniform
          )
        | _ ->
          eprintf "switch %d cannot reach destination\n" sw_val;
          failwith "network disconnected!"

    let resilient_ecmp : Net.Topology.vertex -> string policy =
      let port_tbl = parse_nexthops (base_name ^ "-allsp.nexthops") in
      fun sw ->
        let sw_val = Topology.sw_val topo sw in
        match Hashtbl.find port_tbl sw_val with
        | Some pts -> PNK.(
            do_whl (neg (at_good_pt sw pts)) (
              List.map pts ~f:(fun pt_val -> !!(pt, pt_val))
              |> uniform
            )
          )
        | _ ->
          eprintf "switch %d cannot reach destination\n" sw_val;
          failwith "network disconnected!"

    let car ~(style: [`Deterministic|`Probabilistic])
      : Net.Topology.vertex -> int -> string policy =
      let port_tbl = parse_trees (base_name ^ "-disjointtrees.trees") in
      let current_tree_tbl = mk_current_tree_tbl port_tbl in
      let port_tbl = Int.Table.map port_tbl ~f:Array.of_list in
      fun sw in_pt ->
        let sw_val = Topology.sw_val topo sw in
        match Hashtbl.find current_tree_tbl (sw_val, in_pt) with
        | None ->
          (* eprintf "verify that packets never enter switch %d at port %d\n" sw_val in_pt; *)
          PNK.( drop )
        | Some i ->
          let pts = Hashtbl.find_exn port_tbl sw_val in
          begin match style with
          | `Deterministic ->
            let n = Array.length pts in
            (* the order in which we should try ports, i.e. starting from i *)
            let pts = Array.init n (fun j -> pts.((i+j) mod n)) in
            PNK.(
              Array.to_list pts
              |> ite_cascade ~otherwise:drop ~f:(fun pt_val ->
                  let guard = ???(up sw_val pt_val, 1) in
                  let body = !!(pt, pt_val) in
                  (guard, body)
                )
            )
          | `Probabilistic ->
            failwith "not implemented"
          end
  end

  (* the actual program to run on the switches *)
  let sw_pol = `Switchwise Schemes.resilient_ecmp


end

module Topo = Topology.Make(Parameters)
module Model = Model.Make(Parameters)



(*===========================================================================*)
(* Analyses                                                                  *)
(*===========================================================================*)


(* report whether fdd is equivalent to teleportation, modulo fields *)
let equivalent_to_teleport =
  let teleport = Fdd.of_pol (Model.teleportation ()) in
  let modulo = [Parameters.pt; Parameters.counter] in
  fun fdd ->
    let is_teleport = Fdd.equivalent fdd teleport ~modulo in
    printf "equivalent to teleportation: %s\n" (Bool.to_string is_teleport);
    is_teleport

(* report on probability of delivery *)
(* let probability_of_delivery fdd =
  let ingress_locs = Topo.ingress_locs Parameters.topo in
  List.iter ingress_locs ~f:(fun (sw, pt_val) ->
    let sw_val = Topo.sw_val topo sw in
    match Fdd.(unget (restrict fdd []))
    )
 *)

(* compute path stretch *)


let () = begin
  let open Parameters in

  (* TEST TOPOLOGY *)
  (* let topo_prog = Topo.to_probnetkat topo ~guard_links:true in *)
  (* Format.printf "%a\n\n" Syntax.pp_policy topo_prog; *)
  (* Util.timed "topo to Fdd" (fun () -> ignore (Fdd.of_pol topo_prog)); *)

  (* TEST PARSING *)
  (* ignore (parse_trees @@ base_name ^ "-disjointtrees.trees"); *)

  (* Make model and compile it into an Fdd. *)
  let model = Util.timed "building model" (fun () -> Model.make ()) in
  Format.printf "%a\n\n" Syntax.pp_policy model;
  let fdd = Util.timed "model to Fdd" (fun () -> Fdd.of_pol model) in
  printf ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> COMPILATION DONE\n%!";

  (* erase final port and counter values *)
  (* SJS: we might want to look at the expected number of failures, actually *)
  let fdd' = Fdd.modulo fdd [Parameters.pt; Parameters.counter] in
  printf "fdd mod final port & counter = %s\n" Fdd.(to_string (simplify fdd'));

  (* do we gurantee packet delivery? *)
  ignore (equivalent_to_teleport fdd');

  (* show fdd *)
  Fdd.render fdd' ~title:base_name ~format:"svg";

  (* compute output distribution *)
  let input_dist = Topo.uniform_ingress topo ~dst:destination in
  let output_dist = Fdd.output_dist fdd ~input_dist in
  printf "output distribution:\n%s\n\n" (Packet.Dist.to_string output_dist);
end
