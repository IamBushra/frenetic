<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="previous" href="Frenetic_Vlr.IntPairTbl.html">
<link rel="Up" href="Frenetic_Vlr.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Frenetic_Hashcons" rel="Chapter" href="Frenetic_Hashcons.html">
<link title="Frenetic_Bits" rel="Chapter" href="Frenetic_Bits.html">
<link title="Frenetic_Fdd" rel="Chapter" href="Frenetic_Fdd.html">
<link title="Frenetic_OpenFlow0x04" rel="Chapter" href="Frenetic_OpenFlow0x04.html">
<link title="Frenetic_GroupTable0x04" rel="Chapter" href="Frenetic_GroupTable0x04.html">
<link title="Frenetic_NetKAT" rel="Chapter" href="Frenetic_NetKAT.html">
<link title="Frenetic_NetKAT_Tokens" rel="Chapter" href="Frenetic_NetKAT_Tokens.html">
<link title="Frenetic_NetKAT_Parser" rel="Chapter" href="Frenetic_NetKAT_Parser.html">
<link title="Frenetic_NetKAT_Optimize" rel="Chapter" href="Frenetic_NetKAT_Optimize.html">
<link title="Frenetic_NetKAT_Json" rel="Chapter" href="Frenetic_NetKAT_Json.html">
<link title="Frenetic_NetKAT_Compiler" rel="Chapter" href="Frenetic_NetKAT_Compiler.html">
<link title="Frenetic_NetKAT_FabricGen" rel="Chapter" href="Frenetic_NetKAT_FabricGen.html">
<link title="Frenetic_NetKAT_Virtual_Compiler" rel="Chapter" href="Frenetic_NetKAT_Virtual_Compiler.html">
<link title="Frenetic_NetKAT_Net" rel="Chapter" href="Frenetic_NetKAT_Net.html">
<link title="Frenetic_NetKAT_Pretty" rel="Chapter" href="Frenetic_NetKAT_Pretty.html">
<link title="Frenetic_NetKAT_Semantics" rel="Chapter" href="Frenetic_NetKAT_Semantics.html">
<link title="Frenetic_Network" rel="Chapter" href="Frenetic_Network.html">
<link title="Frenetic_OpenFlow" rel="Chapter" href="Frenetic_OpenFlow.html">
<link title="Frenetic_OpenFlow_Header" rel="Chapter" href="Frenetic_OpenFlow_Header.html">
<link title="Frenetic_OpenFlow0x01" rel="Chapter" href="Frenetic_OpenFlow0x01.html">
<link title="Frenetic_Packet" rel="Chapter" href="Frenetic_Packet.html">
<link title="Frenetic_Topology" rel="Chapter" href="Frenetic_Topology.html">
<link title="Frenetic_Util" rel="Chapter" href="Frenetic_Util.html">
<link title="Frenetic_Vlr" rel="Chapter" href="Frenetic_Vlr.html"><title>Frenetic_Vlr.Make</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Frenetic_Vlr.IntPairTbl.html" title="Frenetic_Vlr.IntPairTbl">Previous</a>
&nbsp;<a class="up" href="Frenetic_Vlr.html" title="Frenetic_Vlr">Up</a>
&nbsp;</div>
<h1>Functor <a href="type_Frenetic_Vlr.Make.html">Frenetic_Vlr.Make</a></h1>

<pre><span class="keyword">module</span> Make: <div class="sig_block"><code class="code">functor (</code><code class="code">V</code><code class="code"> : </code><code class="type"><a href="Frenetic_Vlr.HashCmp.html">HashCmp</a></code><code class="code">) -&gt; </code><div class="sig_block"><code class="code">functor (</code><code class="code">L</code><code class="code"> : </code><code class="type"><a href="Frenetic_Vlr.Lattice.html">Lattice</a></code><code class="code">) -&gt; </code><div class="sig_block"><code class="code">functor (</code><code class="code">R</code><code class="code"> : </code><code class="type"><a href="Frenetic_Vlr.Result.html">Result</a></code><code class="code">) -&gt; </code><code class="code">sig</code> <a href="Frenetic_Vlr.Make.html">..</a> <code class="code">end</code></div></div></div></pre><div class="info module top">
Variable-Lattice-Result
<p>

    This module implements a variant of a binary decision diagrams. Rather than
    representing boolean-valued functions over boolean variables, this data
    structure represents functions that take on values in a semi-ring, and whose
    variables are assigned values from a lattice, i.e., that are partially
    ordered.<br>
</div>
<table border="0" cellpadding="3" width="100%">
<tr>
<td align="left" valign="top" width="1%%"><b>Parameters: </b></td>
<td>
<table class="paramstable">
<tr>
<td align="center" valign="top" width="15%">
<code>V</code></td>
<td align="center" valign="top">:</td>
<td><code class="type"><a href="Frenetic_Vlr.HashCmp.html">HashCmp</a></code>
<tr>
<td align="center" valign="top" width="15%">
<code>L</code></td>
<td align="center" valign="top">:</td>
<td><code class="type"><a href="Frenetic_Vlr.Lattice.html">Lattice</a></code>
<tr>
<td align="center" valign="top" width="15%">
<code>R</code></td>
<td align="center" valign="top">:</td>
<td><code class="type"><a href="Frenetic_Vlr.Result.html">Result</a></code>
</table>
</td>
</tr>
</table>
<hr width="100%">

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> = private <code class="type">int</code> </pre>
<div class="info ">
A decision diagram index.  All diagrams and subdiagrams within it are given an
  index.  You can convert this to a tree with <code class="code">unget</code>, and from a tree with <code class="code">get</code>.<br>
</div>


<pre><span id="TYPEv"><span class="keyword">type</span> <code class="type"></code>v</span> = <code class="type">V.t * L.t</code> </pre>
<div class="info ">
The type of a variable in the decision diagram.<br>
</div>


<pre><span id="TYPEr"><span class="keyword">type</span> <code class="type"></code>r</span> = <code class="type">R.t</code> </pre>
<div class="info ">
The type of the result of a decision diagram<br>
</div>


<pre><code><span id="TYPEd"><span class="keyword">type</span> <code class="type"></code>d</span> = private </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTd.Leaf"><span class="constructor">Leaf</span></span> <span class="keyword">of</span> <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEr">r</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTd.Branch"><span class="constructor">Branch</span></span> <span class="keyword">of</span> <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEv">v</a> * <a href="Frenetic_Vlr.Make.html#TYPEt">t</a> * <a href="Frenetic_Vlr.Make.html#TYPEt">t</a></code></code></td>

</tr></table>



<pre><span class="keyword">module</span> <a href="Frenetic_Vlr.Make.Tbl.html">Tbl</a>: <code class="type">Hashtbl.S</code><code class="type">  with type key = t</code></pre>
<pre><span class="keyword">module</span> <a href="Frenetic_Vlr.Make.BinTbl.html">BinTbl</a>: <code class="type">Hashtbl.S</code><code class="type">  with type key = (t * t)</code></pre>
<pre><span id="VALget"><span class="keyword">val</span> get</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEd">d</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a></code></pre>
<pre><span id="VALunget"><span class="keyword">val</span> unget</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEd">d</a></code></pre>
<pre><span id="VALget_uid"><span class="keyword">val</span> get_uid</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> int</code></pre>
<pre><span id="VALdrop"><span class="keyword">val</span> drop</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEt">t</a></code></pre><br>
<code class="code">drop</code> returns the leaf for a drop operation, which is always present as a leaf node<br>

<pre><span id="VALid"><span class="keyword">val</span> id</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEt">t</a></code></pre><br>
<code class="code">id</code> returns the leaf for the identity operation, which is always present as a leaf node<br>

<pre><span id="VALconst"><span class="keyword">val</span> const</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEr">r</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">const r</code> creates a constant diagram out of <code class="code">r</code>. It's essentially a leaf node with a constant.<br>
</div>

<pre><span id="VALatom"><span class="keyword">val</span> atom</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEv">v</a> -><br>       <a href="Frenetic_Vlr.Make.html#TYPEr">r</a> -> <a href="Frenetic_Vlr.Make.html#TYPEr">r</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">atom v t f</code> creates a diagram that checks the variable assignment
      <code class="code">v</code> holds and returns the result <code class="code">t</code> if it does hold, and the result <code class="code">f</code>
      otherwise.<br>
</div>

<pre><span id="VALcond"><span class="keyword">val</span> cond</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEv">v</a> -><br>       <a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">cond v t f</code> creates a diagram with pattern v, true-branch t and false-branch f.<br>
</div>

<pre><span id="VALunchecked_cond"><span class="keyword">val</span> unchecked_cond</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEv">v</a> -><br>       <a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a></code></pre><div class="info ">
Unsafe!! <code class="code">unchecked_cond v t f</code> behaves like <code class="code">cond v t f</code>, but always puts the pattern <code class="code">v</code>
      in the root node, without ensuring the FDD-ordering invariant is enforced. Only use this if you know what you are doing!<br>
</div>

<pre><span id="VALrestrict"><span class="keyword">val</span> restrict</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEv">v</a> list -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">restrict vs t</code> returns a diagram derived from <code class="code">t</code> and that agrees with
      <code class="code">t</code> when every variable assignment <code class="code">v</code> in <code class="code">vs</code> is true. This will eliminate
      the variables in <code class="code">vs</code> from the diagram, if present.
<p>

      This function assumes that a variable will only appear once in the list of
      variable assignments. If the list assigns multiple values to a variable,
      then the behavior is unspecified.<br>
</div>

<pre><span id="VALsum"><span class="keyword">val</span> sum</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">sum a b</code> returns the disjunction of the two diagrams. The <code class="code">sum</code>
      operation on the <code class="code">r</code> type is used to combine leaf nodes.<br>
</div>

<pre><span id="VALprod"><span class="keyword">val</span> prod</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">prod a b</code> returns the conjunction of the two diagrams. The <code class="code">prod</code>
      operation on the <code class="code">r</code> type is used to combine leaf nodes.<br>
</div>

<pre><span id="VALmap"><span class="keyword">val</span> map</span> : <code class="type">(<a href="Frenetic_Vlr.Make.html#TYPEr">r</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a>) -><br>       (<a href="Frenetic_Vlr.Make.html#TYPEv">v</a> -><br>        <a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a>) -><br>       <a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">map f h t</code> traverses t in post order and first maps the leaves using
      f, and then the internal nodes using h, producing a modified diagram.<br>
</div>

<pre><span id="VALdp_map"><span class="keyword">val</span> dp_map</span> : <code class="type">(<a href="Frenetic_Vlr.Make.html#TYPEr">r</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a>) -><br>       (<a href="Frenetic_Vlr.Make.html#TYPEv">v</a> -><br>        <a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a>) -><br>       <a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -><br>       find_or_add:(<a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -><br>                    default:(unit -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a>) -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a>) -><br>       <a href="Frenetic_Vlr.Make.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">dp_map f h cache t</code> is equal to <code class="code">map f h t</code>, but uses <code class="code">cache</code> for memoization<br>
</div>

<pre><span id="VALmap_r"><span class="keyword">val</span> map_r</span> : <code class="type">(<a href="Frenetic_Vlr.Make.html#TYPEr">r</a> -> <a href="Frenetic_Vlr.Make.html#TYPEr">r</a>) -><br>       <a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">map_r f t</code> returns a diagram with the same structure but whose leaf
      nodes have been modified according the function <code class="code">f</code>.
<p>

      This function can be used as a general form of negation. For example, if
      the <code class="code">r</code> type were <code class="code">bool</code>, one could implement negation in the following
      way:
<p>

          <code class="code">let neg = map_r (fun r -&gt; not r)</code><br>
</div>

<pre><span id="VALfold"><span class="keyword">val</span> fold</span> : <code class="type">(<a href="Frenetic_Vlr.Make.html#TYPEr">r</a> -> 'a) -><br>       (<a href="Frenetic_Vlr.Make.html#TYPEv">v</a> -> 'a -> 'a -> 'a) -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
<code class="code">fold f g t</code> traverses the diagram, replacing leaf nodes with
      applications of <code class="code">f</code> to the values that they hold, and branches on
      variables with applications of <code class="code">g</code>.<br>
</div>

<pre><span id="VALequal"><span class="keyword">val</span> equal</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<code class="code">equal a b</code> returns whether or not the two diagrams are structurally
      equal.
      If two diagrams are structurally equal, then they represent the
      same combinatorial object. However, if two diagrams are not equal, they
      still may represent the same combinatorial object. Whether or not this is
      the case depends on they behavior of the type <code class="code">v</code>.<br>
</div>

<pre><span id="VALsum"><span class="keyword">val</span> sum</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">sum a b</code> returns the disjunction of the two diagrams. The <code class="code">sum</code>
      operation on the <code class="code">r</code> type is used to combine leaf nodes.<br>
</div>

<pre><span id="VALprod"><span class="keyword">val</span> prod</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a></code></pre><div class="info ">
<code class="code">prod a b</code> returns the conjunction of the two diagrams. The <code class="code">prod</code>
      operation on the <code class="code">r</code> type is used to combine leaf nodes.<br>
</div>

<pre><span id="VALcompare"><span class="keyword">val</span> compare</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> <a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> int</code></pre>
<pre><span id="VALto_string"><span class="keyword">val</span> to_string</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> string</code></pre><div class="info ">
<code class="code">to_string t</code> returns a string representation of the diagram.<br>
</div>

<pre><span id="VALclear_cache"><span class="keyword">val</span> clear_cache</span> : <code class="type">preserve:Core.Std.Int.Set.t -> unit</code></pre><div class="info ">
<code class="code">clear_cache ()</code> clears the internal cache of diagrams.<br>
</div>

<pre><span id="VALcompressed_size"><span class="keyword">val</span> compressed_size</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> int</code></pre><div class="info ">
<code class="code">compressed_size t</code> returns the number of nodes in the diagram, duplicates not counted<br>
</div>

<pre><span id="VALuncompressed_size"><span class="keyword">val</span> uncompressed_size</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> int</code></pre><div class="info ">
<code class="code">uncompressed_size t</code> returns the number of nodes in the diagram, duplicates counted<br>
</div>

<pre><span id="VALto_dot"><span class="keyword">val</span> to_dot</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> string</code></pre><div class="info ">
<code class="code">to_dot t</code> returns a string representation of the diagram using the DOT
      graph description language. The result of this function can be rendered
      using Graphviz or any other program that supports the DOT language.<br>
</div>

<pre><span id="VALrefs"><span class="keyword">val</span> refs</span> : <code class="type"><a href="Frenetic_Vlr.Make.html#TYPEt">t</a> -> Core.Std.Int.Set.t</code></pre><div class="info ">
<code class="code">refs t</code> returns set of subdiagrams in this diagram.<br>
</div>
</body></html>