<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Make (frenetic.netkat.Frenetic_netkat.Vlr.Make)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../../index.html">frenetic.netkat</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Frenetic_netkat.Vlr.Make</span></h1></header><div class="doc"><p>Variable-Lattice-Result</p><p>This module implements a variant of a binary decision diagrams. Rather than
representing boolean-valued functions over boolean variables, this data
structure represents functions that take on values in a semi-ring, and whose
variables are assigned values from a lattice, i.e., that are partially
ordered.</p></div><h3 class="heading">Parameters</h3><div><div class="spec argument" id="argument-3-R"><a href="#argument-3-R" class="anchor"></a><div class="def argument"><code><a href="argument-3-R/index.html">R</a> : <a href="../index.html#module-type-Result">Result</a></code></div><div class="doc"></div></div><div class="spec argument" id="argument-2-L"><a href="#argument-2-L" class="anchor"></a><div class="def argument"><code><a href="argument-2-L/index.html">L</a> : <a href="../index.html#module-type-Lattice">Lattice</a></code></div><div class="doc"></div></div><div class="spec argument" id="argument-1-V"><a href="#argument-1-V" class="anchor"></a><div class="def argument"><code><a href="argument-1-V/index.html">V</a> : <a href="../index.html#module-type-HashCmp">HashCmp</a></code></div><div class="doc"></div></div></div><h3 class="heading">Signature</h3><div class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>t</code><code><span class="keyword"> = </span><span class="keyword">private </span>int</code><code></code></div><div class="doc"><p>A decision diagram index. All diagrams and subdiagrams within it are given an
index. You can convert this to a tree with <code class="code">unget</code>, and from a tree with <code class="code">get</code>.</p></div></div><div class="spec type" id="type-v"><a href="#type-v" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>v</code><code><span class="keyword"> = </span><a href="index.html#argument-1-V">V</a>.t<span class="keyword"> * </span><a href="index.html#argument-2-L">L</a>.t</code><code></code></div><div class="doc"><p>The type of a variable in the decision diagram.</p></div></div><div class="spec type" id="type-r"><a href="#type-r" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>r</code><code><span class="keyword"> = </span><a href="index.html#argument-3-R">R</a>.t</code><code></code></div><div class="doc"><p>The type of the result of a decision diagram</p></div></div><div class="spec type" id="type-d"><a href="#type-d" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>d</code><code></code><code><span class="keyword"> = </span><span class="keyword">private </span></code><table class="variant"><tr id="type-d.Leaf" class="anchored"><td class="def constructor"><a href="#type-d.Leaf" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Leaf</span><span class="keyword"> of </span><a href="index.html#type-r">r</a></code></td></tr><tr id="type-d.Branch" class="anchored"><td class="def constructor"><a href="#type-d.Branch" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Branch</span><span class="keyword"> of </span><a href="index.html#type-v">v</a><span class="keyword"> * </span><a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-t">t</a></code></td></tr></table><code></code></div><div class="doc"></div></div><div class="spec module" id="module-Tbl"><a href="#module-Tbl" class="anchor"></a><div class="def module"><code><span class="keyword">module </span>Tbl : Core.Hashtbl.S<span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-Tbl">Tbl</a>.key<span class="keyword"> = </span><a href="index.html#type-t">t</a></code></div><div class="doc"></div></div><div class="spec module" id="module-BinTbl"><a href="#module-BinTbl" class="anchor"></a><div class="def module"><code><span class="keyword">module </span>BinTbl : Core.Hashtbl.S<span class="keyword"> with </span><span class="keyword">type </span><a href="index.html#module-BinTbl">BinTbl</a>.key<span class="keyword"> = </span><a href="index.html#type-t">t</a><span class="keyword"> * </span><a href="index.html#type-t">t</a></code></div><div class="doc"></div></div><div class="spec val" id="val-get"><a href="#val-get" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get : <a href="index.html#type-d">d</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"></div></div><div class="spec val" id="val-unget"><a href="#val-unget" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>unget : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-d">d</a></code></div><div class="doc"></div></div><div class="spec val" id="val-get_uid"><a href="#val-get_uid" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_uid : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"></div></div><div class="spec val" id="val-drop"><a href="#val-drop" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>drop : <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">drop</code> returns the leaf for a drop operation, which is always present as a leaf node</p></div></div><div class="spec val" id="val-id"><a href="#val-id" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>id : <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">id</code> returns the leaf for the identity operation, which is always present as a leaf node</p></div></div><div class="spec val" id="val-const"><a href="#val-const" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>const : <a href="index.html#type-r">r</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">const r</code> creates a constant diagram out of <code class="code">r</code>. It's essentially a leaf node with a constant.</p></div></div><div class="spec val" id="val-atom"><a href="#val-atom" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>atom : <a href="index.html#type-v">v</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-r">r</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-r">r</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">atom v t f</code> creates a diagram that checks the variable assignment
<code class="code">v</code> holds and returns the result <code class="code">t</code> if it does hold, and the result <code class="code">f</code>
otherwise.</p></div></div><div class="spec val" id="val-cond"><a href="#val-cond" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cond : <a href="index.html#type-v">v</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">cond v t f</code> creates a diagram with pattern v, true-branch t and false-branch f.</p></div></div><div class="spec val" id="val-unchecked_cond"><a href="#val-unchecked_cond" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>unchecked_cond : <a href="index.html#type-v">v</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p>Unsafe!! <code class="code">unchecked_cond v t f</code> behaves like <code class="code">cond v t f</code>, but always puts the pattern <code class="code">v</code>
in the root node, without ensuring the FDD-ordering invariant is enforced. Only use this if you know what you are doing!</p></div></div><div class="spec val" id="val-restrict"><a href="#val-restrict" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>restrict : <a href="index.html#type-v">v</a> list <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">restrict vs t</code> returns a diagram derived from <code class="code">t</code> and that agrees with
<code class="code">t</code> when every variable assignment <code class="code">v</code> in <code class="code">vs</code> is true. This will eliminate
the variables in <code class="code">vs</code> from the diagram, if present.</p><p>This function assumes that a variable will only appear once in the list of
variable assignments. If the list assigns multiple values to a variable,
then the behavior is unspecified.</p></div></div><div class="spec val" id="val-sum"><a href="#val-sum" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sum : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">sum a b</code> returns the disjunction of the two diagrams. The <code class="code">sum</code>
operation on the <code class="code">r</code> type is used to combine leaf nodes.</p></div></div><div class="spec val" id="val-prod"><a href="#val-prod" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>prod : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">prod a b</code> returns the conjunction of the two diagrams. The <code class="code">prod</code>
operation on the <code class="code">r</code> type is used to combine leaf nodes.</p></div></div><div class="spec val" id="val-map"><a href="#val-map" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>map : f:(<a href="index.html#type-r">r</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a>) <span class="keyword">&#8209;&gt;</span> g:(<a href="index.html#type-v">v</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a>) <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">map f h t</code> traverses t in post order and first maps the leaves using
f, and then the internal nodes using h, producing a modified diagram.</p></div></div><div class="spec val" id="val-dp_map"><a href="#val-dp_map" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>dp_map : f:(<a href="index.html#type-r">r</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a>) <span class="keyword">&#8209;&gt;</span> g:(<a href="index.html#type-v">v</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a>) <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> find_or_add:(<a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> default:(unit <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a>) <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a>) <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">dp_map f h cache t</code> is equal to <code class="code">map f h t</code>, but uses <code class="code">cache</code> for memoization</p></div></div><div class="spec val" id="val-map_r"><a href="#val-map_r" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>map_r : f:(<a href="index.html#type-r">r</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-r">r</a>) <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">map_r f t</code> returns a diagram with the same structure but whose leaf
nodes have been modified according the function <code class="code">f</code>.</p><p>This function can be used as a general form of negation. For example, if
the <code class="code">r</code> type were <code class="code">bool</code>, one could implement negation in the following
way:</p><p><code class="code">let neg = map_r (fun r -&gt; not r)</code></p></div></div><div class="spec val" id="val-fold"><a href="#val-fold" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>fold : f:(<a href="index.html#type-r">r</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span>) <span class="keyword">&#8209;&gt;</span> g:(<a href="index.html#type-v">v</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span>) <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <span class="type-var">'a</span></code></div><div class="doc"><p><code class="code">fold f g t</code> traverses the diagram, replacing leaf nodes with
applications of <code class="code">f</code> to the values that they hold, and branches on
variables with applications of <code class="code">g</code>.</p></div></div><div class="spec val" id="val-equal"><a href="#val-equal" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>equal : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> bool</code></div><div class="doc"><p><code class="code">equal a b</code> returns whether or not the two diagrams are structurally
equal.
If two diagrams are structurally equal, then they represent the
same combinatorial object. However, if two diagrams are not equal, they
still may represent the same combinatorial object. Whether or not this is
the case depends on they behavior of the type <code class="code">v</code>.</p></div></div><div class="spec val" id="val-sum"><a href="#val-sum" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>sum : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">sum a b</code> returns the disjunction of the two diagrams. The <code class="code">sum</code>
operation on the <code class="code">r</code> type is used to combine leaf nodes.</p></div></div><div class="spec val" id="val-prod"><a href="#val-prod" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>prod : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a></code></div><div class="doc"><p><code class="code">prod a b</code> returns the conjunction of the two diagrams. The <code class="code">prod</code>
operation on the <code class="code">r</code> type is used to combine leaf nodes.</p></div></div><div class="spec val" id="val-compare"><a href="#val-compare" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>compare : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"></div></div><div class="spec val" id="val-to_string"><a href="#val-to_string" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>to_string : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> string</code></div><div class="doc"><p><code class="code">to_string t</code> returns a string representation of the diagram.</p></div></div><div class="spec val" id="val-clear_cache"><a href="#val-clear_cache" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>clear_cache : preserve:Core.Int.Set.t <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">clear_cache ()</code> clears the internal cache of diagrams.</p></div></div><div class="spec val" id="val-compressed_size"><a href="#val-compressed_size" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>compressed_size : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">compressed_size t</code> returns the number of nodes in the diagram, duplicates not counted</p></div></div><div class="spec val" id="val-uncompressed_size"><a href="#val-uncompressed_size" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>uncompressed_size : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> int</code></div><div class="doc"><p><code class="code">uncompressed_size t</code> returns the number of nodes in the diagram, duplicates counted</p></div></div><div class="spec val" id="val-to_dot"><a href="#val-to_dot" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>to_dot : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> string</code></div><div class="doc"><p><code class="code">to_dot t</code> returns a string representation of the diagram using the DOT
graph description language. The result of this function can be rendered
using Graphviz or any other program that supports the DOT language.</p></div></div><div class="spec val" id="val-refs"><a href="#val-refs" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>refs : <a href="index.html#type-t">t</a> <span class="keyword">&#8209;&gt;</span> Core.Int.Set.t</code></div><div class="doc"><p><code class="code">refs t</code> returns set of subdiagrams in this diagram.</p></div></div></body></html>